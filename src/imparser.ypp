%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations
// %expect 2

%define parser_class_name {imparser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    class imdriver;
}

%param { imdriver& driver }
%printer { yyoutput << $$; } <*>;

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "imdriver.hpp"
    #include "imlexer.hpp"
    #undef yylex
    #define yylex driver.lexer->lex
}

%token
    END     0   "end of file"
    NEWLINE 10  "newline"
    // Keywords
    PUSH_KEYW   "push"
    LOAD_KEYW   "load"
    END_KEYW    "end"
    FOR_KEYW    "for"
    IF_KEYW     "if"
    ARGS_KEYW   "args"
    IN_KEYW     "in"
    WRITE_KEYW  "write"
    //
    DOT         "."
    STAR        "*"

%token <std::string>    STRING  "string"
%token <std::string>    IDENTIFIER "identifier"

%%

%start script_unit;

script_unit
        : lines
        ;

load_stmt
        : LOAD_KEYW STRING IDENTIFIER
        ;

push_stmt
        : PUSH_KEYW IDENTIFIER
        ;

for_stmt
        : FOR_KEYW IDENTIFIER IN_KEYW range NEWLINE lines END_KEYW FOR_KEYW
        ;

write_stmt
        : WRITE_KEYW STRING
        ;

range   : IDENTIFIER DOT STAR
        ;

lines   : line lines
        | %empty { }
        ;

line    : load_stmt
        | push_stmt
        | for_stmt
        | write_stmt
        ;
%%

void yy::imparser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}