%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations
// %expect 2

%define parser_class_name {imparser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    class imdriver;
}

%param { imdriver& driver }
%printer { yyoutput << $$; } <*>;

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "imdriver.hpp"
    #include "imlexer.hpp"
    #undef yylex
    #define yylex driver.lexer->lex
}

%token
    END     0   "end of file"
    NEWLINE 10  "newline"
    // Keywords
    END_KEYW    "end"
    FOR_KEYW    "for"
    IF_KEYW     "if"
    IN_KEYW     "in"
    ARGS_KEYW   "args"
    // Symbols
    DOT         "."
    STAR        "*"
    LPAREN      "("
    RPAREN      ")"

%token <std::string>    STRING  "string"
%token <std::string>    IDENTIFIER "identifier"

%%

%start script_unit;

script_unit
        : lines
        ;

range   : IDENTIFIER DOT STAR
        ;

conditional
        : expr
        ;

lines   : line NEWLINE lines
        | %empty { }
        ;

line    : funcall
        | expr
        | for_stmt
        | if_stmt
        ;

expr    : funcall_inner
        | STRING
        | IDENTIFIER
        | range
        ;

// for IDENTIFIER in {range}
//     ...
// end for
for_stmt:
        FOR_KEYW IDENTIFIER IN_KEYW range NEWLINE 
            lines 
        END_KEYW FOR_KEYW
        ;

// if {conditional}
//     ...
// end if
if_stmt :
        IF_KEYW conditional NEWLINE
            lines
        END_KEYW IF_KEYW
        ;

funcall : IDENTIFIER args_list
        ;

funcall_inner
        : IDENTIFIER LPAREN args_list RPAREN
        ;

args_list
        : expr args_list
        | %empty { }
        ;

%%

void yy::imparser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}