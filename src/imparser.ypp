%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations

%define parser_class_name {imparser}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%define parse.trace
%define parse.error verbose
%define api.token.prefix {TOK_}

%code requires
{
    #include <string>
    #include <cstdint>
    class imdriver;
}

%param { imdriver& driver }
%printer { yyoutput << $$; } <*>;

%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%code
{
    #include "imdriver.hpp"
    #include "imlexer.hpp"
    #undef yylex
    #define yylex driver.lexer->lex
}

%token
    END     0   "end of file"
    NEWLINE 10  "newline"
    // Keywords
    END_KEYW    "end"
    FOR_KEYW    "for"
    IF_KEYW     "if"
    IN_KEYW     "in"
    ARGS_KEYW   "args"
    // Symbols
    DOT         "."
    STAR        "*"
    LPAREN      "("
    RPAREN      ")"
    DIM_SEP     "x"

%token <int64_t>        NUMBER "number"
%token <std::string>    STRING "string"
%token <std::string>    IDENTIFIER "identifier"

%%

%start script_unit;

script_unit
        : lines
        ;

range   : IDENTIFIER DOT STAR
        ;

conditional
        : expr
        ;

lines   : line NEWLINE lines
        | %empty { }
        ;

line    : funcall       { std::cout << driver.lexer->loc << "\tline -> funcall" << std::endl; }
        | expr          { std::cout << driver.lexer->loc << "\tline -> expr" << std::endl; }
        | for_stmt      { std::cout << driver.lexer->loc << "\tline -> for_stmt" << std::endl; }
        | if_stmt       { std::cout << driver.lexer->loc << "\tline -> if_stmt" << std::endl; }
        ;

expr    : funcall_inner             { std::cout << driver.lexer->loc << "\texpr -> funcall_inner" << std::endl; }
        | STRING                    { std::cout << driver.lexer->loc << "\texpr -> STRING" << std::endl; }
        | NUMBER                    { std::cout << driver.lexer->loc << "\texpr -> NUMBER" << std::endl; }
        | IDENTIFIER list_access    { std::cout << driver.lexer->loc << "\texpr -> IDENTIFIER list_access" << std::endl; }
        | range                     { std::cout << driver.lexer->loc << "\texpr -> range" << std::endl; }
        | dimension                 { std::cout << driver.lexer->loc << "\texpr -> dimension" << std::endl; }
        ;

// for IDENTIFIER in {range}
//     ...
// end for
for_stmt:
        FOR_KEYW IDENTIFIER IN_KEYW range NEWLINE 
            lines 
        END_KEYW FOR_KEYW
        ;

// if {conditional}
//     ...
// end if
if_stmt :
        IF_KEYW conditional NEWLINE
            lines
        END_KEYW IF_KEYW
        ;

funcall : IDENTIFIER args_list
        ;

funcall_inner
        : IDENTIFIER LPAREN args_list RPAREN
        ;

args_list
        : expr args_list
        | %empty { }
        ;

dimension
        : NUMBER DIM_SEP NUMBER
        ;

list_access
        : DOT NUMBER
        | %empty { }
        ;

%%

void yy::imparser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}